"""
This type stub file was generated by pyright.
"""

from http.client import HTTPConnection
from xmlrpc.client import SafeTransport as XMLSafeTransport, ServerProxy as XMLServerProxy, Transport as XMLTransport, _Method as XML_Method

"""
============================
JSONRPC Library (jsonrpclib)
============================

This library is a JSON-RPC v.2 (proposed) implementation which
follows the xmlrpclib API for portability between clients. It
uses the same Server / ServerProxy, loads, dumps, etc. syntax,
while providing features not present in XML-RPC like:

* Keyword arguments
* Notifications
* Versioning
* Batches and batch notifications

Eventually, I'll add a SimpleXMLRPCServer compatible library,
and other things to tie the thing off nicely. :)

For a quick-start, just open a console and type the following,
replacing the server address, method, and parameters
appropriately.
>>> import jsonrpclib
>>> server = jsonrpclib.Server('http://localhost:8181')
>>> server.add(5, 6)
11
>>> server._notify.add(5, 6)
>>> batch = jsonrpclib.MultiCall(server)
>>> batch.add(3, 50)
>>> batch.add(2, 3)
>>> batch._notify.add(3, 5)
>>> batch()
[53, 5]

See https://github.com/tcalmant/jsonrpclib for more info.

:authors: Josh Marshall, Thomas Calmant
:copyright: Copyright 2025, Thomas Calmant
:license: Apache License 2.0
:version: 0.4.3.4

..

    Copyright 2025 Thomas Calmant

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
"""
__version_info__ = ...
__version__ = ...
__docformat__ = ...
_logger = ...
class ProtocolError(Exception):
    """
    JSON-RPC error

    ProtocolError.args[0] can be:
    * an error message (string)
    * a (code, message) tuple
    """
    ...


class AppError(ProtocolError):
    """
    Application error: the error code is not in the pre-defined ones

    AppError.args[0][0]: Error code
    AppError.args[0][1]: Error message or trace
    AppError.args[0][2]: Associated data
    """
    def data(self): # -> Any:
        """
        Retrieves the value found in the 'data' entry of the error, or None

        :return: The data associated to the error, or None
        """
        ...
    


class TransportError(ProtocolError):
    """
    Transport error: a specialized protocol error
    """
    def __init__(self, url, errcode, errmsg, msg) -> None:
        """
        :param url: Target URL
        :param errcode: HTTP error code
        :param errmsg: HTTP error code description
        :param msg: Exception message
        """
        ...
    
    def __repr__(self): # -> str:
        ...
    


class JSONParser:
    """
    Default JSON parser
    """
    def __init__(self, target) -> None:
        """
        Associates the target loader to the parser

        :param target: a JSONTarget instance
        """
        ...
    
    def feed(self, data): # -> None:
        """
        Feeds the associated target with the given data
        """
        ...
    
    @staticmethod
    def close(): # -> None:
        """
        Does nothing
        """
        ...
    


class JSONTarget:
    """
    Unmarshalls stream data to a string
    """
    def __init__(self) -> None:
        """
        Sets up the unmarshaller
        """
        ...
    
    def feed(self, data): # -> None:
        """
        Stores the given raw data into a buffer
        """
        ...
    
    def close(self): # -> str | Any:
        """
        Unmarshalls the buffered data
        """
        ...
    


class TransportMixIn:
    """ Just extends the XML-RPC transport where necessary. """
    _connection = ...
    readonly_headers = ...
    def __init__(self, config=..., context=...) -> None:
        """
        Sets up the transport

        :param config: A JSONRPClib Config instance
        """
        ...
    
    def push_headers(self, headers): # -> None:
        """
        Adds a dictionary of headers to the additional headers list

        :param headers: A dictionary
        """
        ...
    
    def pop_headers(self, headers): # -> None:
        """
        Removes the given dictionary from the additional headers list.
        Also validates that given headers are on top of the stack

        :param headers: Headers to remove
        :raise AssertionError: The given dictionary is not on the latest stored
                               in the additional headers list
        """
        ...
    
    def emit_additional_headers(self, connection): # -> dict[str, str]:
        """
        Puts headers as is in the request, filtered read only headers

        :param connection: The request connection
        :return: The dictionary of headers added to the connection
        """
        ...
    
    def single_request(self, host, handler, request_body, verbose=...):
        """
        Send a complete request, and parse the response.

        From xmlrpclib in Python 2.7

        :param host: Target host.
        :param handler: Target RPC handler.
        :param request_body: JSON-RPC request body.
        :param verbose: Debugging flag.
        :return: Parsed response.
        """
        ...
    
    def send_request(self, connection, handler, request_body, debug=...):
        """
        Send HTTP request.

        From xmlrpc.client in Python 3.4

        :param connection: Connection handle.
        :param handler: Target RPC handler (a path relative to host)
        :param request_body: The JSON-RPC request body
        :param debug: Enable debugging if debug is true.
        :return: An HTTPConnection.
        """
        ...
    
    def send_content(self, connection, request_body): # -> None:
        """
        Completes the request headers and sends the request body of a JSON-RPC
        request over a HTTPConnection

        :param connection: An HTTPConnection object
        :param request_body: JSON-RPC request body
        """
        ...
    
    @staticmethod
    def getparser(): # -> tuple[JSONParser, JSONTarget]:
        """
        Create an instance of the parser, and attach it to an unmarshalling
        object. Return both objects.

        :return: The parser and unmarshaller instances
        """
        ...
    


class Transport(TransportMixIn, XMLTransport):
    """
    Mixed-in HTTP transport
    """
    def __init__(self, config) -> None:
        ...
    


class SafeTransport(TransportMixIn, XMLSafeTransport):
    """
    Mixed-in HTTPS transport
    """
    def __init__(self, config, context) -> None:
        ...
    


class UnixHTTPConnection(HTTPConnection):
    """
    Replaces the connect() method of HTTPConnection to use a Unix socket
    """
    def __init__(self, path, *args, **kwargs) -> None:
        """
        Constructs the HTTP connection.

        Forwards all given arguments except ``path`` to the constructor of
        HTTPConnection

        :param path: Path to the Unix socket
        """
        ...
    
    def connect(self): # -> None:
        """
        Connects to the described server
        """
        ...
    


class UnixTransport(TransportMixIn, XMLTransport):
    """
    Mixed-in HTTP transport over a UNIX socket
    """
    def __init__(self, config, path=...) -> None:
        """
        :param config: The jsonrpclib configuration
        :param path: Path to the Unix socket (overrides the host name later)
        """
        ...
    
    def make_connection(self, host): # -> UnixHTTPConnection:
        """
        Connect to server.

        Return an existing connection if possible.
        This allows HTTP/1.1 keep-alive.

        Code copied from xmlrpc.client (Python 3)

        :param host: Target host (ignored if a path was given)
        :return A UnixHTTPConnection object
        """
        ...
    


class ServerProxy(XMLServerProxy):
    """
    Unfortunately, much more of this class has to be copied since
    so much of it does the serialization.
    """
    def __init__(self, uri, transport=..., encoding=..., verbose=..., version=..., headers=..., history=..., config=..., context=...) -> None:
        """
        Sets up the server proxy

        :param uri: Request URI
        :param transport: Custom transport handler
        :param encoding: Specified encoding
        :param verbose: Log verbosity level
        :param version: JSON-RPC specification version
        :param headers: Custom additional headers for each request
        :param history: History object (for tests)
        :param config: A JSONRPClib Config instance
        :param context: The optional SSLContext to use
        """
        ...
    
    def __getattr__(self, name): # -> _Method:
        """
        Returns a callable object to call the remote service
        """
        ...
    
    def __call__(self, attr): # -> Callable[[], None] | UnixTransport | SafeTransport | Transport:
        """
        A workaround to get special attributes on the ServerProxy
        without interfering with the magic __getattr__

        (code from xmlrpclib in Python 2.7)
        """
        ...
    


class _Method(XML_Method):
    """
    Some magic to bind an JSON-RPC method to an RPC server.
    """
    def __call__(self, *args, **kwargs):
        """
        Sends an RPC request and returns the unmarshalled result
        """
        ...
    
    def __getattr__(self, name): # -> _Method:
        """
        Returns a Method object for nested calls
        """
        ...
    
    def __repr__(self): # -> str:
        """
        Returns a string representation of the method
        """
        ...
    


class _Notify:
    """
    Same as _Method, but to send notifications
    """
    def __init__(self, request) -> None:
        """
        Sets the method to call to send a request to the server
        """
        ...
    
    def __getattr__(self, name): # -> _Method:
        """
        Returns a Method object, to be called as a notification
        """
        ...
    


class MultiCallMethod:
    """
    Stores calls made to a MultiCall object for batch execution
    """
    def __init__(self, method, notify=..., config=...) -> None:
        """
        Sets up the store

        :param method: Name of the method to call
        :param notify: Notification flag
        :param config: Request configuration
        """
        ...
    
    def __call__(self, *args, **kwargs): # -> None:
        """
        Normalizes call parameters
        """
        ...
    
    def request(self, encoding=..., rpcid=...): # -> str:
        """
        Returns the request object as JSON-formatted string
        """
        ...
    
    def __repr__(self): # -> str:
        """
        String representation
        """
        ...
    
    def __getattr__(self, method): # -> Self:
        """
        Updates the object for a nested call
        """
        ...
    


class MultiCallNotify:
    """
    Same as MultiCallMethod but for notifications
    """
    def __init__(self, multicall, config=...) -> None:
        """
        Sets ip the store

        :param multicall: The parent MultiCall instance
        :param config: Request configuration
        """
        ...
    
    def __getattr__(self, name): # -> MultiCallMethod:
        """
        Returns the MultiCallMethod to use as a notification
        """
        ...
    


class MultiCallIterator:
    """
    Iterates over the results of a MultiCall.
    Exceptions are raised in response to JSON-RPC faults
    """
    def __init__(self, results) -> None:
        """
        Sets up the results store
        """
        ...
    
    def __iter__(self): # -> Generator[Any, Any, None]:
        """
        Iterates over all results
        """
        ...
    
    def __getitem__(self, i):
        """
        Returns the i-th object of the results
        """
        ...
    
    def __len__(self): # -> int:
        """
        Returns the number of results stored
        """
        ...
    


class MultiCall:
    """
    server -> a object used to boxcar method calls, where server should be a
    ServerProxy object.

    Methods can be added to the MultiCall using normal
    method call syntax e.g.:

    multicall = MultiCall(server_proxy)
    multicall.add(2,3)
    multicall.get_address("Guido")

    To execute the multicall, call the MultiCall object e.g.:

    add_result, address = multicall()
    """
    def __init__(self, server, config=...) -> None:
        """
        Sets up the multicall

        :param server: A ServerProxy object
        :param config: Request configuration
        """
        ...
    
    def __getattr__(self, name): # -> MultiCallMethod:
        """
        Registers a method call
        """
        ...
    
    __call__ = ...


Server = ServerProxy
class Fault:
    """
    JSON-RPC error class
    """
    def __init__(self, code=..., message=..., rpcid=..., config=..., data=...) -> None:
        """
        Sets up the error description

        :param code: Fault code
        :param message: Associated message
        :param rpcid: Request ID
        :param config: A JSONRPClib Config instance
        :param data: Extra information added to an error description
        """
        ...
    
    def error(self): # -> dict[str, int | str | Any | None]:
        """
        Returns the error as a dictionary

        :returns: A {'code', 'message'} dictionary
        """
        ...
    
    def response(self, rpcid=..., version=...): # -> str:
        """
        Returns the error as a JSON-RPC response string

        :param rpcid: Forced request ID
        :param version: JSON-RPC version
        :return: A JSON-RPC response string
        """
        ...
    
    def dump(self, rpcid=..., version=...): # -> dict[str, Any | str | None] | dict[str, str | Any | bytes]:
        """
        Returns the error as a JSON-RPC response dictionary

        :param rpcid: Forced request ID
        :param version: JSON-RPC version
        :return: A JSON-RPC response dictionary
        """
        ...
    
    def __repr__(self): # -> str:
        """
        String representation
        """
        ...
    


class Payload:
    """
    JSON-RPC content handler
    """
    def __init__(self, rpcid=..., version=..., config=...) -> None:
        """
        Sets up the JSON-RPC handler

        :param rpcid: Request ID
        :param version: JSON-RPC version
        :param config: A JSONRPClib Config instance
        """
        ...
    
    def request(self, method, params=...): # -> dict[str, str | Any | bytes]:
        """
        Prepares a method call request

        :param method: Method name
        :param params: Method parameters
        :return: A JSON-RPC request dictionary
        """
        ...
    
    def notify(self, method, params=...): # -> dict[str, str | Any | bytes]:
        """
        Prepares a notification request

        :param method: Notification name
        :param params: Notification parameters
        :return: A JSON-RPC notification dictionary
        """
        ...
    
    def response(self, result=...): # -> dict[str, Any | str | None]:
        """
        Prepares a response dictionary

        :param result: The result of method call
        :return: A JSON-RPC response dictionary
        """
        ...
    
    def error(self, code=..., message=..., data=...): # -> dict[str, Any | str | None]:
        """
        Prepares an error dictionary

        :param code: Error code
        :param message: Error message
        :param data: Extra data to associate to the error
        :return: A JSON-RPC error dictionary
        """
        ...
    


def dump(params=..., methodname=..., rpcid=..., version=..., is_response=..., is_notify=..., config=...): # -> dict[str, Any | str | None] | dict[str, str | Any | bytes]:
    """
    Prepares a JSON-RPC dictionary (request, notification, response or error)

    :param params: Method parameters (if a method name is given) or a Fault
    :param methodname: Method name
    :param rpcid: Request ID
    :param version: JSON-RPC version
    :param is_response: If True, this is a response dictionary
    :param is_notify: If True, this is a notification request
    :param config: A JSONRPClib Config instance
    :return: A JSON-RPC dictionary
    """
    ...

def dumps(params=..., methodname=..., methodresponse=..., encoding=..., rpcid=..., version=..., notify=..., config=...): # -> str:
    """
    Prepares a JSON-RPC request/response string

    :param params: Method parameters (if a method name is given) or a Fault
    :param methodname: Method name
    :param methodresponse: If True, this is a response dictionary
    :param encoding: Result string encoding
    :param rpcid: Request ID
    :param version: JSON-RPC version
    :param notify: If True, this is a notification request
    :param config: A JSONRPClib Config instance
    :return: A JSON-RPC dictionary
    """
    ...

def load(data, config=...): # -> bytes | str | int | float | bool | list[bytes | str | int | float | bool | list[bytes | str | int | float | bool | list[Any] | dict[Any, bytes | str | int | float | bool | list[Any] | dict[Any, Any] | Any | None] | Any | None] | dict[Any, bytes | str | int | float | bool | list[Any] | dict[Any, Any] | Any | None] | Any | None] | dict[Any, bytes | str | int | float | bool | list[Any] | dict[Any, Any] | Any | None] | Any | None:
    """
    Loads a JSON-RPC request/response dictionary. Calls jsonclass to load beans

    :param data: A JSON-RPC dictionary
    :param config: A JSONRPClib Config instance (or None for default values)
    :return: A parsed dictionary or None
    """
    ...

def loads(data, config=...): # -> bytes | str | int | float | bool | list[bytes | str | int | float | bool | list[bytes | str | int | float | bool | list[Any] | dict[Any, bytes | str | int | float | bool | list[Any] | dict[Any, Any] | Any | None] | Any | None] | dict[Any, bytes | str | int | float | bool | list[Any] | dict[Any, Any] | Any | None] | Any | None] | dict[Any, bytes | str | int | float | bool | list[Any] | dict[Any, Any] | Any | None] | Any | None:
    """
    Loads a JSON-RPC request/response string. Calls jsonclass to load beans

    :param data: A JSON-RPC string
    :param config: A JSONRPClib Config instance (or None for default values)
    :return: A parsed dictionary or None
    """
    ...

def check_for_errors(result): # -> DictType:
    """
    Checks if a result dictionary signals an error

    :param result: A result dictionary
    :raise TypeError: Invalid parameter
    :raise NotImplementedError: Unknown JSON-RPC version
    :raise ValueError: Invalid dictionary content
    :raise ProtocolError: An error occurred on the server side
    :return: The result parameter
    """
    ...

def isbatch(request): # -> bool:
    """
    Tests if the given request is a batch call, i.e. a list of multiple calls
    :param request: a JSON-RPC request object
    :return: True if the request is a batch call
    """
    ...

def isnotification(request): # -> bool:
    """
    Tests if the given request is a notification

    :param request: A request dictionary
    :return: True if the request is a notification
    """
    ...

